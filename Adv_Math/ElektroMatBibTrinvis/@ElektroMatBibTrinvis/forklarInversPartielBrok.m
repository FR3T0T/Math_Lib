function [f, forklaringsOutput] = forklarInversPartielBrok(F, s, t, params, forklaringsOutput)
    % Forklaring for partiel brøkopløsning
    
    forklaringsOutput = ElektroMatBibTrinvis.tilfoejTrin(forklaringsOutput, 2, ...
        'Identificer funktionstypen som en rationel funktion', ...
        'Funktionen er en rationel funktion, der kan opløses i partialbrøker.', ...
        ['F(s) er en rationel funktion af s']);
    
    forklaringsOutput = ElektroMatBibTrinvis.tilfoejTrin(forklaringsOutput, 3, ...
        'Brug partiel brøkopløsning', ...
        'Vi opløser den rationelle funktion i en sum af simplere brøker.', ...
        'F(s) = A₁/(s-p₁) + A₂/(s-p₂) + ... + B₁/((s-q₁)²+r₁²) + ...');
    
    forklaringsOutput = ElektroMatBibTrinvis.tilfoejTrin(forklaringsOutput, 4, ...
        'Anvend invers transformation på hver delbrøk', ...
        'Vi transformerer hver delbrøk separat ved hjælp af standardformler.', ...
        ['L^(-1){1/(s-a)} = e^(at), L^(-1){b/((s+a)²+b²)} = e^(-at)sin(bt), ...']);
    
    % Beregn partiel brøkopløsning og invers transform - forenklet udgave
    % I en rigtig implementering ville vi beregne dette eksakt
    
    % FIX: Erstat sym('f(t) = sum_of_terms') med sym('f')
    f = sym('f');  % Opret en symbolsk variabel som pladsholder
    
    forklaringsOutput = ElektroMatBibTrinvis.tilfoejTrin(forklaringsOutput, 5, ...
        'Kombiner delresultater', ...
        'Vi samler alle de inverse transformationer til den endelige løsning.', ...
        ['f(t) = sum af alle inverse transformationer af delbrøker for t ≥ 0']);
    
    return;
end